#pragma once

int* SUB_NN_N(int* input1, int* input2){
    int div1 = input1[0];  //считываем количество цифр в первом числе
    int div2 = input2[0];  //считываем количество цифр во втором числе
    int i, j;
    int counter;
    int* num1 = NULL; int* num2 = NULL; //поданые на вход числа, переписанные для удобства от младших разрядов к старшим
    int* diff = NULL;
    int* result_num = NULL;


    if (COM_NN_D(input1, input2) == 0){ //сравниваем числа; если два числа равны, то их разность равна нулю
        diff = (int*)calloc(1, sizeof(int));
        diff[0] = 0;
        return diff;
    }
    else{  //переписываем заданные числа начиная от младших разрядов к старшим
        num1 = (int*)calloc(div1, sizeof(int));
        num2 = (int*)calloc(div1, sizeof(int));
        for (i = 0; i < div1; i++){
            num1[i] = input1[div1 - i];
        }
        for (i = 0; i < div1; i++){
            if (i < div2){
                num2[i] = input2[div2 - i];
            }
            else{ //если количество разрядов второго числа меньше, чем у первого, то вместо недостающих разрядов добавляем нули
                num2[i] = 0;
            }
        }
        counter = 0; //переменная для подсчета цифр в искомой разности
        for (i = 0; i < div1; i++){
            if (num1[i] >= num2[i]){ //если цифра текущего разряда уменьшаемого числа больше либо равна цифре соответствующего разряда вычитаемого числа, вычитаем вторую из первой
                diff = (int*)realloc(diff, (counter + 1)*sizeof(int));
                diff[counter] = num1[i] - num2[i];
                counter++;
            }
            else if (num1[i] < num2[i]){ //иначе делаем "заем" - находим ближайший старший ненулевой разряд и уменьшаем его на единицу
                j = 1;
                while (num1[i + j] == 0){ //нулевые разряды, стоящие перед искомым ненулевым, заменяются на девятки
                    num1[i + j] = 9;
                    j++;
                }
                num1[i + j] = num1[i + j] - 1; //ближайший старший ненулевой разряд уменьшается на единицу
                diff = (int*)realloc(diff, (counter + 1)*sizeof(int));
                diff[counter] = num1[i] + 10 - num2[i]; //к текущей цифре уменьшаемого числа прибавляем 10 и вычитаем из нее соответствующую цифру второго числа
                counter++;
            }
        }
    }
    //теперь у нас есть массив цифр искомого числа diff
    //цифры в нем расположены от младшео разряда к старшему
    while (diff[counter - 1] == 0){ //в полученном числе ищем первый ненулевой старший разряд
        counter--;
    }
    result_num = (int*)calloc(counter + 1, sizeof(int)); //переписываем полученое число от старших разрядов к младшим
    result_num[0] = counter; //добавляем размерность полученного числа
    for (i = 1; i < counter + 1; i++){
        result_num[i] = diff[counter - i]; //сохраняем в массив цифры полученного числа в порядке от старшего разряда к младшим
    }
    return result_num;
}
